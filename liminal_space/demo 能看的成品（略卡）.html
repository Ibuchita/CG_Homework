<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>é˜ˆé™ç©ºé—´ç“·ç –èµ°å»Š - PBRæ¸²æŸ“å™¨</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            font-size: 14px;
            background: rgba(0,0,0,0.7); 
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            line-height: 1.4;
            pointer-events: none;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
            max-width: 250px;
        }
        
        #controls h3 {
            margin-top: 0;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        
        #controls div {
            margin: 5px 0;
        }
        
        #controls kbd {
            background: rgba(255,255,255,0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
    <script type="module" src="./three.module.js"></script>
</head>
<body>
    <div id="info">åŠ è½½ä¸­...</div>
    
    <div id="controls">
        <h3>æ§åˆ¶è¯´æ˜</h3>
        <div><kbd>WASD</kbd> - ç§»åŠ¨</div>
        <div><kbd>é¼ æ ‡æ‹–æ‹½</kbd> - è§†è§’</div>
        <div><kbd>ç©ºæ ¼</kbd>/<kbd>E</kbd> - ä¸Šå‡</div>
        <div><kbd>Shift</kbd>/<kbd>Q</kbd> - ä¸‹é™</div>
        <div><kbd>R</kbd> - é‡ç½®ä½ç½®</div>
        <br>
        <h3>è°ƒè¯•æ§åˆ¶</h3>
        <div><kbd>N</kbd> - åˆ‡æ¢æ³•çº¿è´´å›¾</div>
        <div><kbd>I</kbd> - è°ƒæ•´ç²—ç³™åº¦</div>
        <div><kbd>K</kbd> - è°ƒæ•´é‡‘å±åº¦</div>
        <div><kbd>T</kbd> - è°ƒæ•´ç“·ç –å¤§å°</div>
        <div><kbd>F</kbd> - è°ƒæ•´é›¾æ°”å¼ºåº¦</div>
       
    </div>
    
    <script type="module">
        import * as THREE from './three.module.js';
        
        console.log("ğŸš€ é˜ˆé™ç©ºé—´ç“·ç –èµ°å»Šæ¸²æŸ“å™¨å¯åŠ¨");
        
        // 1. åˆå§‹åŒ–Three.jsæ ¸å¿ƒç»„ä»¶
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            precision: 'highp'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        // ================== ç›¸æœºæ§åˆ¶ ==================
        let cameraPos = new THREE.Vector3(10.0, 2.5, 2.5); // èµ°å»Šä¸­å¿ƒä½ç½®
        let cameraYaw = 0.0; // çœ‹å‘èµ°å»Šå†…éƒ¨
        let cameraPitch = 0.0;
        const cameraSpeed = 0.2;
        const mouseSensitivity = 0.002;

        // é”®ç›˜çŠ¶æ€è®°å½•
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // é¼ æ ‡æ§åˆ¶
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        renderer.domElement.addEventListener('mousedown', (e) => {
            mouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            renderer.domElement.requestPointerLock();
        });

        window.addEventListener('mouseup', () => {
            mouseDown = false;
            document.exitPointerLock();
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.movementX || e.clientX - lastMouseX;
            const deltaY = e.movementY || e.clientY - lastMouseY;
            
            cameraYaw -= deltaX * mouseSensitivity;
            cameraPitch -= deltaY * mouseSensitivity;
            
            // é™åˆ¶ä¿¯ä»°è§’
            cameraPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraPitch));
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        // æ›´æ–°ç›¸æœºçš„å‡½æ•°
        function updateCamera() {
            // æ ¹æ®åèˆªè§’å’Œä¿¯ä»°è§’è®¡ç®—è§†çº¿æ–¹å‘
            const direction = new THREE.Vector3(
                Math.sin(cameraYaw) * Math.cos(cameraPitch),
                Math.sin(cameraPitch),
                -Math.cos(cameraYaw) * Math.cos(cameraPitch)
            ).normalize();
            
            // è®¡ç®—å³ä¾§å‘é‡ï¼ˆç”¨äºå·¦å³ç§»åŠ¨ï¼‰
            const right = new THREE.Vector3(
                Math.sin(cameraYaw + Math.PI/2),
                0,
                -Math.cos(cameraYaw + Math.PI/2)
            ).normalize();
            
            // è®¡ç®—ä¸Šæ–¹å‘é‡
            const up = new THREE.Vector3(0, 1, 0);
            
            // å¤„ç†é”®ç›˜è¾“å…¥
            if (keys['w'] || keys['arrowup']) {
                cameraPos.add(direction.clone().multiplyScalar(cameraSpeed));
            }
            if (keys['s'] || keys['arrowdown']) {
                cameraPos.add(direction.clone().multiplyScalar(-cameraSpeed));
            }
            if (keys['a'] || keys['arrowleft']) {
                cameraPos.add(right.clone().multiplyScalar(-cameraSpeed));
            }
            if (keys['d'] || keys['arrowright']) {
                cameraPos.add(right.clone().multiplyScalar(cameraSpeed));
            }
            if (keys[' '] || keys['e']) {
                cameraPos.add(up.clone().multiplyScalar(cameraSpeed));
            }
            if (keys['shift'] || keys['q']) {
                cameraPos.add(up.clone().multiplyScalar(-cameraSpeed));
            }
            
            // é‡ç½®ç›¸æœºä½ç½®ï¼ˆRé”®ï¼‰
            if (keys['r']) {
                cameraPos.set(10.0, 2.5, 2.5);
                cameraYaw = 0.0;
                cameraPitch = 0.0;
            }
        }

        // ================== åŠ è½½PBRçº¹ç† ==================
        // ä½¿ç”¨ LoadingManager ç­‰å¾…æ‰€æœ‰çº¹ç†åŠ è½½å®Œæˆ
        const manager = new THREE.LoadingManager();
        manager.onLoad = function () {
            console.log("âœ… PBRçº¹ç†åŠ è½½å®Œæˆ");
            // æ‰€æœ‰çº¹ç†åŠ è½½å®Œæˆåå†å¯åŠ¨æ¸²æŸ“
            requestAnimationFrame(animate);
            document.getElementById('info').innerHTML =
                `âœ… é˜ˆé™ç©ºé—´ç“·ç –èµ°å»Š<br>` +
                `ä½ç½®: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})<br>` +
                `æœå‘: yaw=${(cameraYaw * 180/Math.PI).toFixed(1)}Â°, pitch=${(cameraPitch * 180/Math.PI).toFixed(1)}Â°<br>` +
                `å¸§ç‡: -- FPS<br>` +
                `æ­¥è¿›: ${uniforms.uMaxSteps.value}æ¬¡<br>` +
                `è°ƒè¯•æ¨¡å¼: ${uniforms.uDebugMode.value ? 'å¼€' : 'å…³'}`;
        };

        const textureLoader = new THREE.TextureLoader(manager);

        console.log("ğŸ“¦ åŠ è½½PBRçº¹ç†...");

        // åŸºç¡€è‰²è´´å›¾
        const albedoMap = textureLoader.load('Tiles107_2K-PNG_Color.png');
        albedoMap.wrapS = THREE.RepeatWrapping;
        albedoMap.wrapT = THREE.RepeatWrapping;
        albedoMap.colorSpace = THREE.SRGBColorSpace;

        // æ³•çº¿è´´å›¾
        const normalMap = textureLoader.load('Tiles107_2K-PNG_NormalGL.png');
        normalMap.wrapS = THREE.RepeatWrapping;
        normalMap.wrapT = THREE.RepeatWrapping;

        // ç²—ç³™åº¦è´´å›¾
        const roughnessMap = textureLoader.load('Tiles107_2K-PNG_Roughness.png');
        roughnessMap.wrapS = THREE.RepeatWrapping;
        roughnessMap.wrapT = THREE.RepeatWrapping;

        // ç¯å¢ƒå…‰é®è”½è´´å›¾
        const aoMap = textureLoader.load('Tiles107_2K-PNG_AmbientOcclusion.png');
        aoMap.wrapS = THREE.RepeatWrapping;
        aoMap.wrapT = THREE.RepeatWrapping;

        // ä½ç§»è´´å›¾ï¼ˆå¯é€‰ï¼‰
        const displacementMap = textureLoader.load('Tiles107_2K-PNG_Displacement.png');
        displacementMap.wrapS = THREE.RepeatWrapping;
        displacementMap.wrapT = THREE.RepeatWrapping;

        // ================== åˆ›å»ºç€è‰²å™¨æè´¨ ==================
        const ptGeometry = new THREE.PlaneGeometry(2, 2);
        
        // ç€è‰²å™¨uniforms
        const uniforms = {
            time: { value: 1.0 },
            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uCameraPos: { value: new THREE.Vector3(10.0, 2.5, 2.5) },
            uCameraDir: { value: new THREE.Vector3(0.0, 0.0, -1.0) },
            
            // PBRçº¹ç†
            uAlbedoMap: { value: albedoMap },
            uNormalMap: { value: normalMap },
            uRoughnessMap: { value: roughnessMap },
            uAOMap: { value: aoMap },
            uDisplacementMap: { value: displacementMap },
            
            // åœºæ™¯æ§åˆ¶
            uTileSize: { value: 0.5 },
            uCameraOffset: { value: 0.1 },
            
            // å…‰çº¿æ­¥è¿›æ§åˆ¶
            uMinStep: { value: 0.0005 },
            uMaxStep: { value: 0.5 },
            uMaxSteps: { value: 512 },
            
            // PBRæ§åˆ¶
            uNormalStrength: { value: 1.0 },
            uRoughnessFactor: { value: 1.0 },
            uMetallicFactor: { value: 0.0 },
            uLightIntensity: { value: 1.0 },
            
            // é›¾æ°”æ§åˆ¶
            uFogDensity: { value: 0.001 },
            
            // è°ƒè¯•
            uDebugMode: { value: false },
            uDebugType: { value: 0 },

            // åå¤„ç†æ•ˆæœ
            uBlurStrength: { value: 1.2 } // æ¨¡ç³Šå¼ºåº¦ 0.0-1.0
        };

        // åˆ›å»ºç€è‰²å™¨æè´¨
        const ptMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            
            defines: {
                USE_NORMAL_MAP: 1,
                
            },
            
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    // é¡¶ç‚¹è¾“å‡ºå››ç»´æ˜¯GPUå±å¹•åæ ‡å˜æ¢éœ€æ±‚
                    // è¿™é‡Œæ˜¯ç›´æ¥æŠŠé‚£ä¸ªå¹³é¢ä½œä¸ºåº•ç‰‡è´´æˆ‘ä»¬å±å¹•ä¸Šï¼Œå½’ä¸€åŒ–åæ ‡æ˜¯ã€-1ï¼Œ1ã€‘
                    // uvæ˜¯ç”¨äºæ’å€¼è®¡ç®—æ¯ä¸ªåƒç´ åœ¨å¹³é¢ä¸Šçš„åæ ‡ï¼Œä¸æ˜¯æ‹¿å»è´´çº¹ç†
                    // é¡¶ç‚¹å¯åŠ¨å››æ¬¡ï¼Œè¾“å‡ºçš„ç©æ„ä¼šæ’å€¼ï¼Œç›¸å½“äºæ¯æ¬¡ç‰‡å…ƒå¯åŠ¨è®¡ç®—åƒç´ æ—¶ï¼Œéƒ½èƒ½è·å¾—åƒç´ å¯¹åº”çš„åæ ‡
                    gl_Position = vec4(position, 1.0);
                }
            `,
            
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform vec3 uCameraPos;
                uniform vec3 uCameraDir;

                // PBRè´´å›¾
                uniform sampler2D uAlbedoMap;
                uniform sampler2D uNormalMap;
                uniform sampler2D uRoughnessMap;
                uniform sampler2D uAOMap;

                // æ§åˆ¶å‚æ•°
                uniform float uTileSize;
                uniform float uCameraOffset;
                uniform float uMinStep;
                uniform float uMaxStep;
                uniform int uMaxSteps;
                
                // PBRæ§åˆ¶
                uniform float uNormalStrength;
                uniform float uRoughnessFactor;
                uniform float uMetallicFactor;
                uniform float uLightIntensity;
                
                // é›¾æ°”æ§åˆ¶
                uniform float uFogDensity;
                
                // è°ƒè¯•
                uniform bool uDebugMode;
                uniform int uDebugType;
                uniform float uBlurStrength;

                varying vec2 vUv;

                // ========== å¸¸é‡å®šä¹‰ ==========
                const float PI = 3.14159265359;

                // ========== SDFæ ¸å¿ƒå‡½æ•° ==========

                // ç‚¹åˆ°çº¿æ®µè·ç¦»ï¼ˆ2Dï¼‰
                float distanceToSegment(vec2 p, vec2 a, vec2 b) {
                    vec2 ap = p - a;
                    vec2 ab = b - a;
                    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);
                    vec2 closest = a + ab * t;
                    return length(p - closest);
                }

                // å¢™ä½“SDF
                float sdWall(vec3 p, vec2 a, vec2 b, float height, float thickness) {
                    // è®¡ç®—åˆ°å¢™ä½“çš„2Dè·ç¦»
                    float d2 = distanceToSegment(p.xz, a, b);
                    
                    // å¢™ä½“åšåº¦
                    float wallDist = d2 - thickness;
                    
                    // å¢™ä½“é«˜åº¦é™åˆ¶
                    float verticalDist = max(p.y - height, -p.y);
                    
                    // å¦‚æœåœ¨é«˜åº¦èŒƒå›´å†…ï¼Œåªè€ƒè™‘æ°´å¹³è·ç¦»
                    if(p.y >= 0.0 && p.y <= height) {
                        return max(wallDist, 0.0);
                    } else {
                        // åœ¨é«˜åº¦èŒƒå›´å¤–ï¼Œè®¡ç®—åˆ°è¾¹ç¼˜çš„è·ç¦»
                        return length(vec2(max(wallDist, 0.0), max(verticalDist, 0.0)));
                    }
                }

                // åœ°æ¿SDF
                float sdFloor(vec3 p) {
                    return p.y;
                }

                // å¤©èŠ±æ¿SDF
                float sdCeiling(vec3 p, float height) {
                    return height - p.y;
                }

                // å®Œæ•´åœºæ™¯SDF - å›å»Šç»“æ„
                float sceneSDF(vec3 p) {
                    float wallHeight = 5.0;
                    float thickness = 0.2;
                    
                    float dist = 1e10;
                    
                    // å¤–å¢™ - å½¢æˆLå‹å›å»Š
                    dist = min(dist, sdWall(p, vec2(0.0, 0.0), vec2(20.0, 0.0), wallHeight, thickness));
                    dist = min(dist, sdWall(p, vec2(20.0, 0.0), vec2(20.0, 15.0), wallHeight, thickness));
                    dist = min(dist, sdWall(p, vec2(20.0, 15.0), vec2(0.0, 15.0), wallHeight, thickness));
                    dist = min(dist, sdWall(p, vec2(0.0, 15.0), vec2(0.0, 0.0), wallHeight, thickness));
                    
                    // ä¸­é—´éš”æ–­å¢™
                    dist = min(dist, sdWall(p, vec2(5.0, 0.0), vec2(5.0, 10.0), wallHeight, thickness * 1.5));
                    
                    // åœ°æ¿å’Œå¤©èŠ±æ¿
                    dist = min(dist, sdFloor(p));
                    dist = min(dist, sdCeiling(p, wallHeight));
                    
                    return dist;
                }

                // ========== å®‰å…¨çš„å…‰çº¿æ­¥è¿› ==========
                // roæ˜¯ç›¸æœºé’ˆå­”åæ ‡ï¼Œrdæ˜¯å°„çº¿å‘é‡
                // è¿™è¾¹è¦ä¹ˆæ˜¯è¿ˆæ­¥è¿‡äº†è¢«å‰”é™¤ï¼Œè¦ä¹ˆå°±æ˜¯æ­¥é•¿ä¸å¤Ÿå¤Ÿä¸ç€è¢«å‰”é™¤ï¼ˆå°¤å…¶äºŒåˆ†ç²¾ä¿®æ—¶ï¼‰
                float safeRaymarch(vec3 ro, vec3 rd) {
                    float depth = 0.001;
                    float lastDist = sceneSDF(ro);

                    for(int i = 0; i < uMaxSteps; i++) {
                    // æ²¿å°„çº¿è¿ˆæ­¥å–ç‚¹ï¼Œæ‰¾åˆ°ç‚¹åœ¨é¢ä¸Šçš„ï¼ˆSDFé¦–æ¬¡è¶‹è¿‘äº0ï¼‰
                        vec3 p = ro + depth * rd;
                        float dist = sceneSDF(p);

                        
                        // ç²¾ä¿®æ„ä¹‰ä¸å¤§ï¼Œä¸€èˆ¬è¯¯å·®åœ¨0.005å·¦å³å°±æ²¡é—®é¢˜äº†
                        // è¿™é‡Œä½äº†æœ‰å¯èƒ½å‡ºç°ç©ºç¼ºï¼Œé«˜äº†ä¼šæ‰­æ›²
                        // åœ†ç¯æ˜¯åˆšå¥½åœ¨æ­£å¯¹çš„æ—¶å€™ä¼šå‡ºç°éå¸¸åœ†ï¼Œæ‰€ä»¥æœ‰ç†ç”±æ€€ç–‘æ˜¯åˆšå¥½è¿ˆæ­¥è¿ˆè¿‡äº†è¢«å‰”é™¤äº†
                        // ç»™å¢™å†å¢åŠ åšåº¦ï¼Œå’Œå¢åŠ ç©¿è¶Šæ£€å®šè¿˜æ˜¯æœ‰å¿…è¦çš„
                        if(abs(dist) < 0.005)
                        {
                            return depth;
                        }

                        // æ£€æµ‹è¡¨é¢ç©¿è¶Š
                        if(lastDist * dist < 0.0) {
                            // é«˜ç²¾åº¦äºŒåˆ†æŸ¥æ‰¾ - ä½¿ç”¨é¢„ä¼°çš„æ­¥é•¿
                            float estimatedStepSize = 0.1;
                            float t0 = max(depth - estimatedStepSize, 0.0);
                            float t1 = depth;

                            for(int j = 0; j < 8; j++) {
                                float tMid = (t0 + t1) * 0.5;
                                if(sceneSDF(ro + tMid * rd) < 0.0) {
                                    t1 = tMid;
                                } else {
                                    t0 = tMid;
                                }
                            }
                            return (t0 + t1) * 0.5;
                        }

                        // ä¿å®ˆçš„è‡ªé€‚åº”æ­¥é•¿ - é¿å…è¿‡åº¦è·³è·ƒ
                        float stepSize;

                        // æœ‰ç‚¹ç±»ä¼¼é¢„çƒ­å’Œé€€ç«
                        if(dist < 0.5) {
                            stepSize = max(dist * 0.7, uMinStep);
                        } else if(dist < 5.0) {
                            stepSize = clamp(dist * 0.4, uMinStep, 0.8);
                        } else {
                            stepSize = clamp(dist * 0.15, uMinStep * 2.0, uMaxStep * 0.5);
                        }

                        // æ›´ä¸¥æ ¼çš„æ­¥é•¿é™åˆ¶
                        stepSize = min(stepSize, dist * 1.2);
                        stepSize = max(stepSize, uMinStep);

                        lastDist = dist;
                        depth += stepSize;
                        // è·ç¦»å¤§äº100æ—¶è§†ä½œèƒŒæ™¯ï¼Œå‰”é™¤ã€‚bugä¸€èˆ¬è·Ÿè¿™ä¸ªæ— å…³
                        if(depth > 100.0) break;
                    }

                    return -1.0;
                }


                // ========== æ³•çº¿è®¡ç®— ==========
                vec3 calcNormal(vec3 p) {
                    // åŠ¨æ€epsilon - åŸºäºè·ç¦»è°ƒæ•´ç²¾åº¦
                    float baseEps = 0.001;
                    float distFactor = min(1.0, length(p) * 0.001);
                    float eps = baseEps * (1.0 + distFactor);


                    // è¯´æ˜¯SDFæ¢¯åº¦çš„ç»å…¸ç®—æ³•å°±æ˜¯è¿™æ ·ï¼Œæ˜¯ä¸ªè¿‘ä¼¼å€¼ï¼Œé‚£æ— æ‰€è°“äº†
                    vec3 n;
                    n.x = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));
                    n.y = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));
                    n.z = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));

                    float len = length(n);

                    // è¿™ä¸ªæ˜¯é˜²æ­¢å¤ªå°äº†å‡ºç°ç²¾åº¦é”™è¯¯å˜æˆ0ï¼Œæ‰€ä»¥ä¼šåœ¨è¿™ç§æƒ…å†µä¸‹é»˜è®¤è¿”å›å‘ä¸Šçš„æ³•çº¿
                    /*if(len < 0.0001) {
                        return vec3(0.0, 1.0, 0.0);
                    }*/

                    return normalize(n);
                }

                // ========== PBRè¾…åŠ©å‡½æ•° ==========
                // è¿™å››ä¸ªç»„åˆè®¡ç®—BRDF

                // å¾®æ³•çº¿åˆ†å¸ƒï¼Œç”¨åˆ°äº†ç²—ç³™åº¦ï¼Œä¹Ÿå°±æ˜¯è¯´ç²—ç³™åº¦ç°åœ¨å¯ä»¥æ§åˆ¶é«˜å…‰ï¼Œè¯´æ˜¯åŠçƒå†…ç§¯åˆ†ä¸º1
                float DistributionGGX(vec3 N, vec3 H, float roughness) {
                    float a = roughness * roughness;
                    float a2 = a * a;
                    float NdotH = max(dot(N, H), 0.0);
                    float NdotH2 = NdotH * NdotH;
                    
                    float num = a2;
                    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
                    denom = PI * denom * denom;
                    
                    return num / denom;
                }

                // æè¿°è‡ªé˜´å½±ï¼Œç²—ç³™è¶Šå¤§å¾®è¡¨é¢è¢«å…¶ä»–å¾®è¡¨é¢é®ä½è¶Šå¤š
                float GeometrySchlickGGX(float NdotV, float roughness) {
                    float r = (roughness + 1.0);
                    float k = (r * r) / 8.0;
                    
                    float num = NdotV;
                    float denom = NdotV * (1.0 - k) + k;
                    
                    return num / denom;
                }

                // å…¥å°„å’Œå‡ºå°„çš„å‡ ä½•é®è”½
                float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
                    float NdotV = max(dot(N, V), 0.0);
                    float NdotL = max(dot(N, L), 0.0);
                    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
                    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
                    
                    return ggx1 * ggx2;
                }

                // è²æ¶…å°”æ•ˆåº”ï¼Œæ å°„è§’æ›´äº®ï¼ˆæ‹¿å»åšæè¾¹çš„é‚£ä¸ªï¼Œf0æ˜¯åå°„ç‡ï¼‰ï¼Œè¯´æ˜¯è¿™éƒ¨åˆ†ä¿æŒäº†èƒ½é‡å®ˆæ’ï¼Œåå°„åŠ æŠ˜å°„ä¸ºä¸€
                vec3 fresnelSchlick(float cosTheta, vec3 F0) {
                    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
                }

                // ========== çº¹ç†åæ ‡ç”Ÿæˆ ==========
                vec2 getTileUV(vec3 p, vec3 normal) {
                    vec2 uv;

                    // é«˜ç²¾åº¦çº¹ç†åæ ‡ç”Ÿæˆ - ç¡®ä¿è¿œè·ç¦»ç²¾åº¦ 
                    // å¼ºåˆ¶ä½¿ç”¨é«˜ç²¾åº¦ï¼Œé¿å…ç¼–è¯‘å™¨ç»™æ”¹æˆä½ç²¾åº¦å¯¼è‡´è´´å›¾å¯¹ä¸é½
                    vec3 p_high = p + vec3(0.0);

                    if(abs(normal.y) > 0.8) {
                        // åœ°æ¿/å¤©èŠ±æ¿ - ä½¿ç”¨åŒå€ç²¾åº¦
                        uv = p_high.xz * uTileSize;// å¯ä»¥ç”¨çª—å£æ¥çœ‹ï¼Œç›¸å½“äºè´´å›¾è¾¹é•¿ä¹˜å€æ•°ï¼Œç„¶åæŠ¹æ‰å°æ•°ç‚¹å°±æ˜¯å¾€å›å¹³ç§»
                        uv = fract(uv + vec2(0.1, 0.1)); // æ·»åŠ åç§»é¿å…å¯¹é½
                    } else {
                        // å¢™é¢ - æ ¹æ®ä¸»æ–¹å‘é€‰æ‹©æœ€ä½³æŠ•å½±
                        float nx = abs(normal.x);
                        float ny = abs(normal.y);
                        float nz = abs(normal.z);

                        if(nx > ny && nx > nz) {
                            // Xæ–¹å‘å¢™é¢ - æŠ•å½±åˆ°YZå¹³é¢
                            uv = p_high.yz * uTileSize;
                        } else if(nz > ny) {
                            // Zæ–¹å‘å¢™é¢ - æŠ•å½±åˆ°XYå¹³é¢
                            uv = p_high.xy * uTileSize;
                        } else {
                            // ç‰¹æ®Šæƒ…å†µï¼Œå›é€€åˆ°XYå¹³é¢
                            uv = p_high.xy * uTileSize;
                        }
                        uv = fract(uv);
                    }
                   

                    return uv;
                }

                // å…‰ç…§éƒ¨åˆ†
                    /*1. è¾“å…¥å‡†å¤‡
                        â†“
                        2. ç›´æ¥å…‰ç…§è®¡ç®—ï¼ˆç‚¹å…‰æº/æ–¹å‘å…‰ï¼‰
                        â†“
                        3. é—´æ¥å…‰ç…§è®¡ç®—ï¼ˆå…¨å±€å…‰ç…§ï¼‰
                        â†“
                        4. ç¯å¢ƒå…‰é®è”½ï¼ˆAOï¼‰
                        â†“
                        5. åå¤„ç†æ•ˆæœ
                    */
                // åå°„åŠ æŠ˜å°„ <= å…¥å°„


                // ========== ç¯å¢ƒå…‰ç…§è®¡ç®— ==========

                // ç¯å¢ƒå…‰é®è”½ï¼Œç”¨æ¥æ¨¡æ‹Ÿé™„è¿‘ç‰©ä½“çš„é®å…‰ã€‚é‡‡æ ·æ³•çº¿æ¥è®¡ç®—åŠçƒå†…çš„è¡¨é¢ï¼ˆSDF=0ï¼‰ï¼Œä»¥æ­¤å‰Šå‡ao
                // æ”¹è¿›çš„ç¯å¢ƒé®è”½è®¡ç®— - è€ƒè™‘ç›´æ¥å…‰ç…§å½±å“
                float calculateAmbientOcclusion(vec3 p, vec3 normal) {
                    float ao = 1.0;
                    int samples = 6; // å‡å°‘é‡‡æ ·æ•°
                    float radius = 1.5; // å‡å°é‡‡æ ·åŠå¾„

                    // ç®€åŒ–çš„AOè®¡ç®—
                    for(int i = 0; i < samples; i++) {
                        float angle = float(i) / float(samples) * 2.0 * PI;
                        vec3 sampleDir = normalize(normal +
                            vec3(cos(angle), sin(angle) * 0.3, sin(angle)) * 0.2);

                        float sampleDist = sceneSDF(p + sampleDir * radius);
                        ao -= max(0.0, (1.0 - sampleDist / radius)) * 0.05; // å‡å¼±AOå¼ºåº¦
                    }

                    return clamp(ao, 0.4, 1.0); // å¹³è¡¡çš„AOèŒƒå›´
                }

                /*float calculateAmbientOcclusion(vec3 p, vec3 normal) {
                    float ao = 1.0;
                    int samples = 6;
                    float radius = 1.5;
                    float bias = 0.01; // é¿å…è‡ªç›¸äº¤
                    
                    // æ„å»ºåˆ‡çº¿ç©ºé—´çš„åŸºç¡€å‘é‡
                    vec3 tangent, bitangent;
                    if(abs(normal.x) > 0.8) {
                        tangent = vec3(0.0, 0.0, 1.0);
                    } else {
                        tangent = vec3(1.0, 0.0, 0.0);
                    }
                    tangent = normalize(cross(normal, tangent));
                    bitangent = cross(normal, tangent);
                    
                    for(int i = 0; i < samples; i++) {
                        // ä½¿ç”¨æ›´åˆç†çš„éšæœºæ–¹å‘ç”Ÿæˆ
                        float angle = float(i) / float(samples) * 2.0 * PI;
                        
                        // ä½™å¼¦åŠ æƒåŠçƒé‡‡æ ·
                        float u = float(i) / float(samples);
                        float r = sqrt(u);
                        float theta = 2.0 * PI * u;
                        
                        vec3 localSample = vec3(
                            r * cos(theta),
                            r * sin(theta),
                            sqrt(1.0 - u) // ä½™å¼¦åŠ æƒ
                        );
                        
                        // è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´
                        vec3 sampleDir = normalize(
                            tangent * localSample.x +
                            bitangent * localSample.y +
                            normal * localSample.z
                        );
                        
                        // é‡‡æ ·ç‚¹ä½ç½®ï¼ˆé¿å…è‡ªç›¸äº¤ï¼‰
                        vec3 samplePos = p + normal * bias + sampleDir * radius;
                        float sampleDist = sceneSDF(samplePos);
                        
                        // æ›´å‡†ç¡®çš„é®æŒ¡è®¡ç®—
                        if(sampleDist <= 0.0) {
                            // åœ¨å‡ ä½•ä½“å†…éƒ¨ï¼Œå®Œå…¨é®æŒ¡
                            ao -= 1.0 / float(samples);
                        } else {
                            // éƒ¨åˆ†é®æŒ¡ï¼ŒåŸºäºè·ç¦»
                            float visibility = smoothstep(0.0, 1.0, sampleDist / radius);
                            ao -= (1.0 - visibility) * 0.7 / float(samples);
                        }
                    }
                    
                    return clamp(ao, 0.3, 1.0);
                }*/

                // ========== åªè®¡ç®—ç›´æ¥å…‰ç…§ï¼ˆé¿å…é€’å½’è°ƒç”¨ï¼‰ ==========
                vec3 calculateDirectLightingOnly(vec3 p, vec3 viewDir, vec3 normal, vec2 uv, vec3 lightPos, vec3 lightColor) {


                    // é‡‡æ ·çº¹ç†
                    vec3 albedo = texture2D(uAlbedoMap, uv).rgb;
                    vec3 texNormal = texture2D(uNormalMap, uv).xyz * 2.0 - 1.0;
                    float roughness = texture2D(uRoughnessMap, uv).r * uRoughnessFactor;

                    // æ²¡æœ‰é‡‘å±åº¦è´´å›¾ï¼Œæ¯•ç«Ÿä¸æ˜¯é‡‘å±ã€‚ä½†æ˜¯é‡‘å±åº¦å¾®è°ƒä¸€ç‚¹è¿˜æŒºå¥½çœ‹
                    float metallic = uMetallicFactor;


                    // å¤„ç†æ³•çº¿è´´å›¾
                    #ifdef USE_NORMAL_MAP
                        vec3 worldNormal = normalize(normal);
                        vec3 tangentNormal = normalize(texNormal);

                        vec3 tangent = vec3(1.0, 0.0, 0.0);
                        if(abs(worldNormal.x) > 0.8) {
                            tangent = vec3(0.0, 0.0, 1.0);
                        }
                        vec3 bitangent = normalize(cross(worldNormal, tangent));
                        tangent = normalize(cross(bitangent, worldNormal));

                        mat3 tbn = mat3(tangent, bitangent, worldNormal);
                        vec3 finalNormal = normalize(tbn * tangentNormal);
                        finalNormal = normalize(mix(worldNormal, finalNormal, uNormalStrength));
                    #else
                        vec3 finalNormal = normalize(normal);
                    #endif
                    
                    vec3 Lo = vec3(0.0);

                    // è®¡ç®—ç›´æ¥å…‰ç…§
                    vec3 lightDir = normalize(lightPos - p);
                    float distance = length(lightPos - p);

                    float NdotL = max(dot(finalNormal, lightDir), 0.0);

                        if(NdotL > 0.01) {
                            // é˜´å½±æ£€æµ‹
                            float bias = 0.02 + (1.0 - NdotL) * 0.02;
                            float shadowDist = safeRaymarch(p + finalNormal * bias, lightDir);

                            float shadow = 1.0;
                            if(shadowDist > 0.0 && shadowDist < distance * 0.99) {
                                shadow = 0.0;
                            }

                            // å…‰ç…§è¡°å‡
                            float attenuation = 1.0 / (distance * distance);
                            attenuation = pow(attenuation, 0.9);
                            vec3 radiance = lightColor * attenuation * shadow;

                            // Cook-Torrance BRDF
                            vec3 halfwayDir = normalize(lightDir + viewDir);
                            vec3 F0 = mix(vec3(0.04), albedo, metallic);
                            vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);

                            float NDF = DistributionGGX(finalNormal, halfwayDir, roughness);
                            float G = GeometrySmith(finalNormal, viewDir, lightDir, roughness);

                            vec3 numerator = NDF * G * F;
                            float denominator = 4.0 * max(dot(finalNormal, viewDir), 0.0) * NdotL + 0.0001;
                            vec3 specular = numerator / denominator;

                            vec3 kS = F;
                            vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);

                            vec3 diffuse = kD * albedo / PI;

                            Lo += (diffuse + specular) * radiance * NdotL;
                    }

                    return Lo;
                }

                // å¤šçº§é—´æ¥å…‰ç…§è®¡ç®— - å±•å¼€é€’å½’ä¸ºå¾ªç¯ï¼ˆGLSLä¸æ”¯æŒé€’å½’ï¼‰
                vec3 calculateIndirectLighting(vec3 p, vec3 normal, vec3 viewDir, float roughness, vec3 albedo, float metallic , vec3 lightPos , vec3 lightColor) {
                    vec3 indirectLight = vec3(0.0);

                    // å›ºå®šæœ€å¤§åå¼¹æ¬¡æ•° - å±•å¼€é€’å½’
                    // è¿™ä¸ªåº“ä¸æ”¯æŒé€’å½’å•Š
                    //const int MAX_BOUNCES = 3;

                    // ç¬¬0çº§ï¼šä»å½“å‰ç‚¹å¼€å§‹çš„é‡‡æ ·
                    const int SAMPLE_COUNT = 3; // å‡å°‘é‡‡æ ·æ•°æé«˜æ€§èƒ½
                    vec3 totalRadiance = vec3(0.0);
                    float totalWeight = 0.0;

                    for(int i = 0; i < SAMPLE_COUNT; i++) {
                        // åœ¨åŠçƒå†…ç”Ÿæˆå‡åŒ€éšæœºæ–¹å‘
                        // æ˜¯å‡è®¾æœ‰è¯¥æ–¹å‘çš„é—´æ¥å…‰ï¼Œè‹¥å‡»ä¸­å°±è®¡ç®—
                        float u1 = (float(i) + 0.5) / float(SAMPLE_COUNT);
                        float u2 = fract(u1 * 2.0 * PI);

                        // ä½¿ç”¨ä½™å¼¦åŠ æƒé‡‡æ · - é‡è¦æ€§é‡‡æ ·
                        float theta = acos(sqrt(u1));
                        float phi = u2 * 2.0 * PI;

                        // æ„å»ºåˆ‡çº¿ç©ºé—´çš„é‡‡æ ·æ–¹å‘ï¼Œä¸‰ç»´èµ‹å€¼
                        vec3 sampleDir;
                        sampleDir.x = sin(theta) * cos(phi);
                        sampleDir.y = cos(theta);
                        sampleDir.z = sin(theta) * sin(phi);

                        // è½¬æ¢åˆ°ä¸–ç•Œç©ºé—´
                        vec3 tangent, bitangent;
                        if(abs(normal.x) < 0.9) {
                            tangent = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));
                        } else {
                            tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
                        }
                        bitangent = normalize(cross(normal, tangent));

                        // è®¡ç®—å®é™…æ–¹å‘
                        vec3 worldSampleDir = normalize(
                            sampleDir.x * tangent +
                            sampleDir.y * normal +
                            sampleDir.z * bitangent
                        );

                        // ä½™å¼¦åŠ æƒè€å‡ æ ·äº†

                        // æŠ•å°„é—´æ¥å…‰çº¿æ¥æº
                        float hitDistance = safeRaymarch(p + normal * 0.02, worldSampleDir);

                        if(hitDistance > 0.0) {
                            vec3 hitPoint = p + normal * 0.02 + worldSampleDir * hitDistance;
                            vec3 hitNormal = calcNormal(hitPoint);
                            vec2 hitUV = getTileUV(hitPoint, hitNormal);
                            vec3 hitViewDir = normalize(-worldSampleDir);

                            // è®¡ç®—å‡»ä¸­ç‚¹çš„ç›´æ¥å…‰ç…§
                            //vec3 lightPos = vec3(10.0, 4.0, 7.5);
                            //vec3 lightColor = vec3(1.0, 0.85, 0.6) * 2.0 * uLightIntensity;
                            vec3 hitColor = calculateDirectLightingOnly(hitPoint, hitViewDir, hitNormal, hitUV, lightPos, lightColor);

                            // ç¬¬1çº§åå°„ï¼šä»å‡»ä¸­ç‚¹ç»§ç»­é‡‡æ ·ï¼ˆæ¨¡æ‹Ÿä¸€æ¬¡é€’å½’ï¼‰
                            vec3 secondBounceLight = vec3(0.0);
                            if(hitDistance < 15.0) { // è·ç¦»é™åˆ¶
                                // ç®€åŒ–çš„äºŒæ¬¡åå¼¹ - åªé‡‡æ ·1ä¸ªæ–¹å‘
                                vec3 secondSampleDir = normalize(reflect(worldSampleDir, hitNormal));

                                // ç®€åŒ–çš„æ¼«åå°„é‡‡æ ·ï¼Œæ²¡å•¥å¤ªå¤§åŒºåˆ«
                                /*
                                // åŸºäºç²—ç³™åº¦çš„æ¨¡ç³Šåå°„
                                vec3 perfectReflect = reflect(worldSampleDir, hitNormal);
                                float roughnessFactor = roughness; // ä½¿ç”¨å‡»ä¸­ç‚¹çš„ç²—ç³™åº¦

                                // æ·»åŠ éšæœºæ‰°åŠ¨
                                vec3 randomVec = normalize(vec3(
                                    cos(float(i) * 2.39996) * 0.8,
                                    sin(float(i) * 7.8537) * 0.8,
                                    (cos(float(i) * 3.14159) + sin(float(i) * 6.28318)) * 0.5
                                ));

                                vec3 secondSampleDir = normalize(mix(perfectReflect, randomVec, roughnessFactor));
                                */


                                secondSampleDir.y = max(secondSampleDir.y, 0.1); // é¿å…å‘ä¸‹

                                float secondHitDistance = safeRaymarch(hitPoint + hitNormal * 0.02, secondSampleDir);

                                if(secondHitDistance > 0.1 && secondHitDistance < 10.0) {
                                    vec3 secondHitPoint = hitPoint + hitNormal * 0.02 + secondSampleDir * secondHitDistance;
                                    vec3 secondHitNormal = calcNormal(secondHitPoint);
                                    vec2 secondHitUV = getTileUV(secondHitPoint, secondHitNormal);
                                    vec3 secondHitViewDir = normalize(-secondSampleDir);

                                    // è®¡ç®—ç¬¬äºŒçº§å‡»ä¸­ç‚¹çš„ç›´æ¥å…‰ç…§
                                    vec3 secondHitColor = calculateDirectLightingOnly(secondHitPoint, secondHitViewDir, secondHitNormal, secondHitUV, lightPos, lightColor);

                                    // ç¬¬äºŒçº§åå°„è¡°å‡æ›´å¼º
                                    float firstBounceAtt = 1.0 / (1.0 + hitDistance * 0.15);
                                    float secondBounceAtt = 1.0 / (1.0 + secondHitDistance * 0.25);

                                    secondBounceLight = secondHitColor * firstBounceAtt * secondBounceAtt * 0.3;
                                }
                            }

                            hitColor += secondBounceLight;

                            // è®¡ç®—BRDFæƒé‡
                            float cosTheta = max(dot(normal, worldSampleDir), 0.0);
                            float hitCosTheta = max(dot(hitNormal, -worldSampleDir), 0.0);

                            // Cook-Torrance BRDFç®€åŒ–ç‰ˆæœ¬
                            vec3 halfwayDir = normalize(viewDir + worldSampleDir);
                            vec3 F0 = mix(vec3(0.04), albedo, metallic);
                            vec3 F = F0 + (1.0 - F0) * pow(1.0 - max(dot(halfwayDir, viewDir), 0.0), 5.0);

                            float NDF = DistributionGGX(normal, halfwayDir, roughness);
                            float G = GeometrySmith(normal, viewDir, worldSampleDir, roughness);

                            vec3 numerator = NDF * G * F;
                            float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * cosTheta + 0.0001;
                            vec3 specular = numerator / denominator;

                            vec3 kS = F;
                            vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
                            vec3 diffuse = kD * albedo / PI;

                            vec3 brdf = diffuse + specular;

                            // PDFæƒé‡ (ä½™å¼¦åŠ æƒé‡‡æ ·çš„PDF = cosTheta / PI)
                            float pdf = cosTheta / PI;
                            float weight = cosTheta / pdf; // è’™ç‰¹å¡æ´›æƒé‡

                            // è·ç¦»è¡°å‡
                            float distanceAtt = 1.0 / (1.0 + hitDistance * 0.1);

                            // ç´¯åŠ è¾å°„åº¦
                            totalRadiance += hitColor * brdf * cosTheta * distanceAtt * weight;
                            totalWeight += weight;
                        }
                    }

                    // è’™ç‰¹å¡æ´›ç§¯åˆ† - è®¡ç®—æœŸæœ›å€¼
                    if(totalWeight > 0.0) {
                        indirectLight = totalRadiance / float(SAMPLE_COUNT);

                        // æ•´ä½“å¼ºåº¦æ§åˆ¶
                        indirectLight *= 0.4; // æ§åˆ¶é—´æ¥å…‰ç…§å¼ºåº¦
                    }

                    return indirectLight;
                }

                // ========== å®Œæ•´çš„PBRå…‰ç…§ ==========
                vec3 fullPBRLighting(vec3 p, vec3 viewDir, vec3 normal, vec2 uv) {
                    // é‡‡æ ·çº¹ç†
                    vec3 albedo = texture2D(uAlbedoMap, uv).rgb;
                    vec3 texNormal = texture2D(uNormalMap, uv).xyz * 2.0 - 1.0;
                    float roughness = texture2D(uRoughnessMap, uv).r * uRoughnessFactor;
                    float metallic = uMetallicFactor;
                    float ao = texture2D(uAOMap, uv).r;

                    // åŠ å¼ºæ³•çº¿è´´å›¾å½±å“
                    #ifdef USE_NORMAL_MAP
                        vec3 worldNormal = normalize(normal);
                        vec3 tangentNormal = normalize(texNormal);

                        // æ„å»ºTBNçŸ©é˜µ
                        vec3 tangent = vec3(1.0, 0.0, 0.0);
                        if(abs(worldNormal.x) > 0.8) {
                            tangent = vec3(0.0, 0.0, 1.0);
                        }
                        vec3 bitangent = normalize(cross(worldNormal, tangent));
                        tangent = normalize(cross(bitangent, worldNormal));

                        mat3 tbn = mat3(tangent, bitangent, worldNormal);
                        vec3 finalNormal = normalize(tbn * tangentNormal);
                        finalNormal = normalize(mix(worldNormal, finalNormal, uNormalStrength));
                    #else
                        vec3 finalNormal = normalize(normal);
                    #endif

                    // ç“·ç –è¾¹ç¼˜æ£€æµ‹ - æ”¹è¿›ç‰ˆæœ¬ï¼ŒåŸºäºè·ç¦»è‡ªé€‚åº”
                    vec2 tileUV = uv * 4.0;
                    vec2 tilePos = fract(tileUV);
                    float tileEdge = smoothstep(0.45, 0.55, abs(tilePos.x - 0.5)) +
                                     smoothstep(0.45, 0.55, abs(tilePos.y - 0.5));

                    // å…‰æºå®šä¹‰ - åªä½¿ç”¨ä¸€ä¸ªå…‰æºï¼Œé¿å…æœªåˆå§‹åŒ–é—®é¢˜
                    vec3 lightPositions[1];
                    lightPositions[0] = vec3(8.0, 4.0, 4.5);  // ä¸»å…‰æº

                    // å‡ºå£é‚£ç§ç»¿è‰² 0.2 0.7 0.3
                    vec3 lightColors[1] = vec3[1](
                        vec3(1.0, 0.8, 0.3) * 2.0 * uLightIntensity   // æš–é»„è‰²
                    );

                    vec3 Lo = vec3(0.0);
                    vec3 indirectLight = vec3(0.0);

                    // è®¡ç®—æ¯ä¸ªå…‰æºçš„è´¡çŒ®
                    for(int i = 0; i < 1; i++) {
                        vec3 lightDir = normalize(lightPositions[i] - p);
                        float distance = length(lightPositions[i] - p);

                        // æ”¹è¿›çš„é˜´å½±æ£€æµ‹ - ä¸“é—¨å¤„ç†éš”æ–­å¢™é—®é¢˜
                        float shadow = 1.0;

                        // è®¡ç®—è¡¨é¢ä¸å…‰æºçš„è§’åº¦
                        float NdotL = max(dot(finalNormal, lightDir), 0.0);

    
                        // èƒŒé¢ä¸æ¥æ”¶ç›´æ¥å…‰ç…§ - ä½¿ç”¨æ ‡å‡†ç‰©ç†æ–¹æ³•
                        if(NdotL <= 0.01) {
                            shadow = 0.0; // èƒŒé¢å®Œå…¨åœ¨é˜´å½±ä¸­
                        } else {
                            // é€šç”¨é˜´å½±æ£€æµ‹ - é€‚ç”¨äºæ‰€æœ‰è¡¨é¢
                            if(i == 0 || lightColors[i].r > 0.1) { // å¯¹ä¸»è¦å…‰æºè¿›è¡Œé˜´å½±æ£€æµ‹
                                float viewDist = length(p - uCameraPos);
                                // ç§»é™¤è·ç¦»é™åˆ¶ - æ‰€æœ‰åœ°æ–¹éƒ½åº”è¯¥æ£€æµ‹é˜´å½±
                                // é€šç”¨é˜´å½±åç§» - åŸºäºè¡¨é¢è§’åº¦è‡ªåŠ¨è°ƒæ•´
                                float bias = 0.02 + (1.0 - NdotL) * 0.02;

                                float shadowDist = safeRaymarch(p + finalNormal * bias, lightDir);

                                // æ ‡å‡†é˜´å½±æ£€æµ‹
                                if(shadowDist > 0.0 && shadowDist < distance * 0.99) {
                                    shadow = 0.0; // å®Œå…¨é˜´å½±
                                } else {
                                    shadow = 1.0; // å®Œå…¨å…‰ç…§
                                }
                            }
                        }

                        // ç‰©ç†æ­£ç¡®çš„å…‰ç…§è¡°å‡ - ç§»é™¤æœ€å°å…‰ç…§å¼ºåº¦
                        float attenuation = 1.0 / (distance * distance);

                        // è½»å¾®çš„è·ç¦»è¡°å‡æ§åˆ¶ - ä¿æŒçœŸå®æ„Ÿ
                        attenuation = pow(attenuation, 0.9);

                        vec3 radiance = lightColors[i] * attenuation * shadow;

                        // Cook-Torrance BRDF
                        vec3 halfwayDir = normalize(lightDir + viewDir);

                        // æ³•çº¿åˆ†å¸ƒå‡½æ•°
                        float NDF = DistributionGGX(finalNormal, halfwayDir, roughness);

                        // å‡ ä½•å‡½æ•°
                        float G = GeometrySmith(finalNormal, viewDir, lightDir, roughness);

                        // è²æ¶…å°”æ–¹ç¨‹
                        vec3 F0 = mix(vec3(0.04), albedo, metallic);
                        vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);

                        // é•œé¢åå°„éƒ¨åˆ†
                        vec3 numerator = NDF * G * F;
                        float denominator = 4.0 * max(dot(finalNormal, viewDir), 0.0) * max(dot(finalNormal, lightDir), 0.0) + 0.0001;
                        vec3 specular = numerator / denominator;

                        // æ¼«åå°„éƒ¨åˆ†
                        vec3 kS = F;
                        vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);

                        // NdotLå·²ç»åœ¨å‰é¢è®¡ç®—äº†
                        vec3 diffuse = kD * albedo / PI;

                        // ç´¯åŠ å…‰ç…§è´¡çŒ® - ä½¿ç”¨ä¹‹å‰è®¡ç®—çš„NdotL
                        Lo += (diffuse + specular) * radiance * NdotL;

                        // çœŸæ­£çš„é—´æ¥å…‰ç…§ - å¤šçº§åå°„å…‰çº¿è¿½è¸ª
                        indirectLight += calculateIndirectLighting(p, finalNormal, viewDir, roughness, albedo, metallic, lightPositions[i],lightColors[i]);
                    }

                    // åŸºäºSDFçš„ç¯å¢ƒå…‰ç…§è®¡ç®— - æ¨¡æ‹Ÿé€’å½’å…‰çº¿è¿½è¸ª
                    float ao_value = calculateAmbientOcclusion(p, finalNormal);

                    // å‡å°‘ç¯å¢ƒå…‰å¼ºåº¦ï¼Œçªå‡ºé—´æ¥å…‰ç…§æ•ˆæœ
                    float final_ao = ao_value;
                    vec3 ambient = final_ao * albedo * 0.02;  // å‡ ä¹å…³é—­ç¯å¢ƒå…‰

                    

                    // ç»„åˆæ‰€æœ‰å…‰ç…§ - åŒ…å«çœŸæ­£çš„é—´æ¥å…‰ç…§
                    vec3 color = ambient + indirectLight + Lo;

                    
                    // æ”¹è¿›çš„ç“·ç –æ•ˆæœå¤„ç† - è€ƒè™‘å…‰ç…§å¼ºåº¦
                    float totalLightIntensity = length(Lo);
                    float lightFactor = min(totalLightIntensity / 2.0, 1.0); // å½’ä¸€åŒ–å…‰ç…§å¼ºåº¦

                    if(tileEdge > 0.5) {
                        // ç“·ç –æ¥ç¼ - åœ¨å¼ºå…‰ä¸‹å‡å¼±å˜æš—æ•ˆæœ
                        float darknessFactor = mix(0.85, 0.95, lightFactor); // å¼ºå…‰æ—¶åªç¨å¾®å˜æš—
                        color *= darknessFactor;
                        roughness = min(roughness + 0.15, 1.0);
                    } else {
                        // ç“·ç –è¡¨é¢æœ‰è½»å¾®é•œé¢æ•ˆæœ - å¤§å¹…å‡å°‘
                        color += vec3(0.005) * (1.0 - roughness) * lightFactor;
                    }

                    return color;
                }

                // ========== è°ƒè¯•å¯è§†åŒ– ==========
                vec3 debugVisualization(vec3 ro, vec3 rd, float t) {
                    if(uDebugType == 1) {
                        // è·ç¦»åœºå¯è§†åŒ–
                        if(t > 0.0) {
                            vec3 p = ro + t * rd;
                            float dist = sceneSDF(p);
                            return vec3(dist * 0.5);
                        } else {
                            vec3 p = ro + rd * 50.0;
                            float dist = sceneSDF(p);
                            return vec3(dist * 0.1);
                        }
                    } else if(uDebugType == 2) {
                        // æ­¥æ•°/æ·±åº¦å¯è§†åŒ–
                        return vec3(t * 0.02);
                    } else if(uDebugType == 3) {
                        // æ³•çº¿å¯è§†åŒ–
                        if(t > 0.0) {
                            vec3 p = ro + t * rd;
                            vec3 normal = calcNormal(p);
                            return normal * 0.5 + 0.5;
                        } else {
                            return vec3(0.0);
                        }
                    }
                    
                    return vec3(0.0);
                }

                // ========== ä¸»å‡½æ•° ==========
                void main() {
                    vec2 uv = (vUv - 0.5) * 2.0;
                    uv.x *= resolution.x / resolution.y;
                    
                    vec3 ro = uCameraPos;
                    vec3 rd = uCameraDir;
                    
                    // æ„å»ºç›¸æœºåæ ‡ç³»
                    vec3 worldUp = vec3(0.0, 1.0, 0.0);
                    vec3 cameraRight = normalize(cross(rd, worldUp));
                    vec3 cameraUp = normalize(cross(cameraRight, rd));
                    
                    // è®¡ç®—å°„çº¿æ–¹å‘
                    rd = normalize(rd + uv.x * cameraRight + uv.y * cameraUp);
                    
                    // è¿›è¡Œå…‰çº¿æ­¥è¿›
                    float t = safeRaymarch(ro, rd);
                    
                    // è°ƒè¯•æ¨¡å¼
                    if(uDebugMode) {
                        vec3 color = debugVisualization(ro, rd, t);
                        gl_FragColor = vec4(color, 1.0);
                        return;
                    }
                    
                    // æ­£å¸¸æ¸²æŸ“
                    vec3 color;
                    if(t > 0.0) {
                        // å‡»ä¸­è¡¨é¢
                        vec3 p = ro + t * rd;
                        vec3 normal = calcNormal(p);
                        vec2 texUV = getTileUV(p, normal);
                        vec3 viewDir = normalize(uCameraPos - p);
                        
                        // è®¡ç®—PBRå…‰ç…§
                        color = fullPBRLighting(p, viewDir, normal, texUV);
                        
                        // ç®€åŒ–çš„é›¾æ°”æ•ˆæœ
                        float fog = exp(-t * uFogDensity);
                        // æ ¹æ®è·ç¦»ä¸åŒï¼Œæ··åˆé¢œè‰²ä¹Ÿä¸åŒ
                        fog = clamp(fog, 0.3, 1.0); // ç¡®ä¿è¿‘è·ç¦»ä¸ä¼šå®Œå…¨é€æ˜
                        vec3 fogColor = vec3(0.28, 0.64, 0.62);
                        color = mix(fogColor, color, fog);
                        
                    } else {
                        // èƒŒæ™¯ - é˜ˆé™ç©ºé—´é£æ ¼
                        color = vec3(0.02, 0.03, 0.05);
                    }
                    
                    // è‰²è°ƒæ˜ å°„å’Œä¼½é©¬æ ¡æ­£
                    color = color / (color + vec3(1.0));
                    color = pow(color, vec3(1.0/2.2));

                    // è½»é‡çº§é¢œè‰²æ¨¡ç³Šæ•ˆæœ
                    if(uBlurStrength > 0.0) {
                        // ç®€å•çš„é‚»åŸŸé¢œè‰²æ··åˆ - åŸºäºå±å¹•åæ ‡
                        vec2 texel = 1.0 / vec2(800.0, 600.0);

                        // ä½¿ç”¨å±å¹•åæ ‡ç”Ÿæˆéšæœºä½†å¯é‡å¤çš„é¢œè‰²åç§»
                        vec2 screenCoord = gl_FragCoord.xy;
                        float noise1 = fract(sin(dot(screenCoord, vec2(12.9898, 78.233))) * 43758.5453);
                        float noise2 = fract(sin(dot(screenCoord, vec2(78.233, 12.9898))) * 43758.5453);

                        // åˆ›å»ºç®€å•çš„é¢œè‰²åç§»
                        vec3 colorShift = vec3(
                            sin(noise1 * 6.283) * 0.1,
                            cos(noise2 * 6.283) * 0.1,
                            sin((noise1 + noise2) * 3.1415) * 0.1
                        );

                        // åº”ç”¨æ¨¡ç³Š - ä¸»è¦æ˜¯é™ä½å¯¹æ¯”åº¦å’Œè½»å¾®çš„é¢œè‰²æ··åˆ
                        float blurAmount = uBlurStrength * 0.3;
                        color = mix(color, color + colorShift, blurAmount);

                        // é™ä½é¥±å’Œåº¦å’Œäº®åº¦æ¨¡æ‹Ÿæ¨¡ç³Šæ•ˆæœ
                        float luminance = dot(color, vec3(0.299, 0.587, 0.114));
                        color = mix(color, vec3(luminance), blurAmount * 0.5);

                        // è½»å¾®çš„äº®åº¦è°ƒèŠ‚
                        color *= (1.0 - blurAmount * 0.1);
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        
        const ptPlane = new THREE.Mesh(ptGeometry, ptMaterial);
        scene.add(ptPlane);
        
        // ================== åŠ¨ç”»å¾ªç¯ ==================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç›¸æœºä½ç½®å’Œæ–¹å‘
            updateCamera();
            
            // è®¡ç®—ç›¸æœºæ–¹å‘å‘é‡
            const direction = new THREE.Vector3(
                Math.sin(cameraYaw) * Math.cos(cameraPitch),
                Math.sin(cameraPitch),
                -Math.cos(cameraYaw) * Math.cos(cameraPitch)
            ).normalize();
            
            // æ›´æ–°ç€è‰²å™¨uniforms
            uniforms.uCameraPos.value.copy(cameraPos);
            uniforms.uCameraDir.value.copy(direction);
            uniforms.time.value = clock.getElapsedTime();
            uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
            
            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            const fps = Math.round(1/clock.getDelta());
            document.getElementById('info').innerHTML = 
                `âœ… é˜ˆé™ç©ºé—´ç“·ç –èµ°å»Š<br>` +
                `ä½ç½®: (${cameraPos.x.toFixed(2)}, ${cameraPos.y.toFixed(2)}, ${cameraPos.z.toFixed(2)})<br>` +
                `æœå‘: yaw=${(cameraYaw * 180/Math.PI).toFixed(1)}Â°, pitch=${(cameraPitch * 180/Math.PI).toFixed(1)}Â°<br>` +
                `å¸§ç‡: ${fps} FPS<br>` +
                `æ­¥è¿›: ${uniforms.uMaxSteps.value}æ¬¡<br>` +
                `è°ƒè¯•æ¨¡å¼: ${uniforms.uDebugMode.value ? 'å¼€' : 'å…³'}`;
        }
        
        // ================== çª—å£å¤§å°è°ƒæ•´ ==================
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });
        
        // ================== è°ƒè¯•æ§åˆ¶ ==================
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            
            // N: åˆ‡æ¢æ³•çº¿è´´å›¾
            if (key === 'n') {
                if (ptMaterial.defines.USE_NORMAL_MAP) {
                    delete ptMaterial.defines.USE_NORMAL_MAP;
                } else {
                    ptMaterial.defines.USE_NORMAL_MAP = 1;
                }
                ptMaterial.needsUpdate = true;
                console.log(`æ³•çº¿è´´å›¾: ${ptMaterial.defines.USE_NORMAL_MAP ? 'å¼€å¯' : 'å…³é—­'}`);
            }
            
            // k: è°ƒæ•´é‡‘å±åº¦å› å­
            if (key === 'k') {
                uniforms.uMetallicFactor.value = uniforms.uMetallicFactor.value > 2.0 ? 0.0 : uniforms.uMetallicFactor.value + 0.2;
                console.log(`é‡‘å±åº¦å› å­: ${uniforms.uMetallicFactor.value.toFixed(2)}`);
            }

              // i: è°ƒæ•´ç²—ç³™åº¦å› å­
            if (key === 'i') {
                uniforms.uRoughnessFactor.value = uniforms.uRoughnessFactor.value > 2.0 ? 0.0 : uniforms.uRoughnessFactor.value + 0.2;
                console.log(`ç²—ç³™åº¦å› å­: ${uniforms.uRoughnessFactor.value.toFixed(2)}`);
            }
            
            // T: è°ƒæ•´ç“·ç –å¤§å°
            if (key === 't') {
                uniforms.uTileSize.value = uniforms.uTileSize.value > 2.0 ? 0.2 : uniforms.uTileSize.value + 0.1;
                console.log(`ç“·ç –å¤§å°: ${uniforms.uTileSize.value.toFixed(2)}`);
            }
            
            // F: è°ƒæ•´é›¾æ°”å¼ºåº¦
            if (key === 'f') {
                uniforms.uFogDensity.value = uniforms.uFogDensity.value > 0.2 ? 0.00 : uniforms.uFogDensity.value + 0.001;
                console.log(`é›¾æ°”å¼ºåº¦: ${uniforms.uFogDensity.value.toFixed(3)}`);
            }
            
            // +: å¢åŠ å…‰ç…§å¼ºåº¦
            if (key === '=' || key === '+') {
                uniforms.uLightIntensity.value *= 1.2;
                console.log(`å…‰ç…§å¼ºåº¦: ${uniforms.uLightIntensity.value.toFixed(2)}`);
            }

            // H: è°ƒæ•´æ¨¡ç³Šå¼ºåº¦
            if (key === 'h') {
                uniforms.uBlurStrength.value = uniforms.uBlurStrength.value > 1.0 ? 0.0 : uniforms.uBlurStrength.value + 0.1;
                console.log(`æ¨¡ç³Šå¼ºåº¦: ${uniforms.uBlurStrength.value.toFixed(1)}`);
            }
            
            // -: å‡å°å…‰ç…§å¼ºåº¦
            if (key === '-' || key === '_') {
                uniforms.uLightIntensity.value *= 0.8;
                console.log(`å…‰ç…§å¼ºåº¦: ${uniforms.uLightIntensity.value.toFixed(2)}`);
            }
            
            // [: å‡å°‘æœ€å¤§æ­¥æ•°
            if (key === '[') {
                uniforms.uMaxSteps.value = Math.max(64, uniforms.uMaxSteps.value - 64);
                console.log(`æœ€å¤§æ­¥æ•°: ${uniforms.uMaxSteps.value}`);
            }
            
            // ]: å¢åŠ æœ€å¤§æ­¥æ•°
            if (key === ']') {
                uniforms.uMaxSteps.value = Math.min(1024, uniforms.uMaxSteps.value + 64);
                console.log(`æœ€å¤§æ­¥æ•°: ${uniforms.uMaxSteps.value}`);
            }
        });

        // ================== å¯åŠ¨åŠ¨ç”»å¾ªç¯ ==================
        console.log("âœ… æ¸²æŸ“å™¨åˆå§‹åŒ–å®Œæˆï¼Œç­‰å¾…çº¹ç†åŠ è½½...");
        console.log("ğŸ“‹ ä½¿ç”¨è¯´æ˜:");
        console.log("  - WASDç§»åŠ¨ï¼Œé¼ æ ‡æ‹–æ‹½è§†è§’");
        console.log("  - ç©ºæ ¼/Eä¸Šå‡ï¼ŒShift/Qä¸‹é™");
        console.log("  - Ré‡ç½®ç›¸æœºä½ç½®");
        console.log("  - Nåˆ‡æ¢æ³•çº¿è´´å›¾ï¼ŒIè°ƒæ•´ç²—ç³™åº¦ï¼ŒKè°ƒæ•´é‡‘å±åº¦");
        console.log("  - Tè°ƒæ•´ç“·ç –å¤§å°ï¼ŒFè°ƒæ•´é›¾æ°”å¼ºåº¦");
        console.log("  - +/-è°ƒæ•´å…‰ç…§å¼ºåº¦");
        console.log("  - animate() ä¼šåœ¨çº¹ç†åŠ è½½å®Œæˆåè‡ªåŠ¨å¯åŠ¨");

        // æ³¨æ„ï¼šanimate() ç°åœ¨ç”± LoadingManager.onLoad å›è°ƒè§¦å‘
    </script>
</body>
</html>